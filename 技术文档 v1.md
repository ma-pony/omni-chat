# OmniChat WXT技术架构文档 v1

| **文档版本** | **日期** | **作者** | **状态** | **修订说明** |
| :--- | :--- | :--- | :--- | :--- |
| 3.0 | 2025年8月27日 | Claude | 技术架构重构 | 基于WXT框架和@webext-core/messaging重新设计架构 |

## 1. 技术栈概览

### 1.1 核心技术选型

| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **WXT** | Latest | 扩展框架 | 提供HMR、自动manifest生成、跨浏览器支持 |
| **Vue.js** | 3.x | UI框架 | 响应式组件，用于popup和独立页面 |
| **@webext-core/messaging** | Latest | 消息通信 | 类型安全的消息传递框架 |
| **@webext-core/storage** | Latest | 存储管理 | 类型安全的存储API封装 |
| **TypeScript** | 5.x | 类型系统 | 提供类型安全和更好的IDE支持 |
| **Vite** | 5.x | 构建工具 | WXT内置，提供快速的HMR |
| **Tailwind CSS** | 3.x | 样式框架 | 原子化CSS，快速开发 |
| **Pinia** | 2.x | 状态管理 | Vue3的轻量级状态管理 |
| **Xpath** | 最新版 | 元素选择 | 使用xpath来选择页面元素，提供更强大更通用的功能 |


### 1.2 WXT项目结构

```
omnichat/
├── .wxt/                      # WXT生成的文件（自动）
├── assets/                    # 静态资源
│   ├── icons/                # 扩展图标和平台logo
│   └── styles/              # 全局样式
├── components/              # Vue组件
│   ├── common/             # 通用组件
│   ├── platform/           # 平台相关组件
│   └── workspace/          # 工作台组件
├── entrypoints/            # WXT入口点（重要）
│   ├── background.ts       # 后台脚本
│   ├── content/           # Content Scripts
│   │   ├── index.ts       # 通用content script
│   │   └── adapters/      # 平台适配器
│   ├── popup/             # 弹窗界面
│   │   ├── index.html
│   │   ├── main.ts
│   │   └── App.vue
│   └── omnichat.html      # 独立工作台页面
├── lib/                    # 核心库
│   ├── messaging/         # 消息系统
│   ├── storage/           # 存储管理
│   └── platforms/         # 平台配置
├── public/                # 公共文件
├── utils/                 # 工具函数
├── wxt.config.ts         # WXT配置文件
├── package.json
└── tsconfig.json
```

## 2. WXT配置与设置

### 2.1 WXT配置文件

```typescript
// wxt.config.ts
import { defineConfig } from 'wxt';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  // 使用Vue插件
  vite: () => ({
    plugins: [vue()],
  }),

  // Manifest配置
  manifest: {
    name: 'OmniChat - AI协作工作台',
    description: '统一的多平台AI交互工具',
    version: '1.0.0',

    permissions: [
      'storage',
      'tabs',
      'scripting',
      'activeTab'
    ],

    host_permissions: [
      'https://chat.openai.com/*',
      'https://claude.ai/*',
      'https://gemini.google.com/*',
      'https://poe.com/*',
      'https://chat.deepseek.com/*'
    ],

    // 浏览器特定设置
    browser_specific_settings: {
      gecko: {
        id: 'omnichat@extension.dev',
        strict_min_version: '109.0'
      }
    },

    // 动作配置
    action: {
      default_popup: 'popup.html',
      default_icon: {
        16: '/icons/icon-16.png',
        32: '/icons/icon-32.png',
        48: '/icons/icon-48.png',
        128: '/icons/icon-128.png'
      }
    }
  },

  // 模块配置
  modules: [
    '@wxt-dev/module-vue'  // Vue支持模块
  ],

  // 开发配置
  runner: {
    startUrls: [
      'https://chat.openai.com',
      'https://claude.ai'
    ]
  },

  // 构建配置
  zip: {
    artifactTemplate: 'omnichat-{{version}}-{{browser}}.zip'
  }
});
```

### 2.2 入口点定义

```typescript
// entrypoints/background.ts
import { defineBackground } from 'wxt/sandbox';
import { initializeMessaging } from '@/lib/messaging';
import { ConnectionManager } from '@/lib/platforms/connection-manager';
import { MessageDispatcher } from '@/lib/messaging/dispatcher';

export default defineBackground(() => {
  console.log('OmniChat Background Script Started');

  // 初始化消息系统
  initializeMessaging();

  // 初始化连接管理器
  const connectionManager = new ConnectionManager();

  // 初始化消息分发器
  const dispatcher = new MessageDispatcher(connectionManager);

  // 监听扩展安装
  browser.runtime.onInstalled.addListener(() => {
    console.log('OmniChat installed');
    // 打开工作台
    browser.tabs.create({
      url: browser.runtime.getURL('/omnichat.html')
    });
  });
});
```

## 3. 消息系统架构（使用@webext-core/messaging）

### 3.1 消息协议定义

```typescript
// lib/messaging/protocol.ts
import { defineExtensionMessaging } from '@webext-core/messaging';

// 定义消息协议映射
export interface ProtocolMap {
  // 连接管理
  'connection:establish': (data: {
    platformId: PlatformType;
  }) => Promise<ConnectionResult>;

  'connection:disconnect': (data: {
    platformId: PlatformType;
  }) => Promise<void>;

  'connection:status': (data: {
    platformId: PlatformType;
  }) => ConnectionState;

  'connection:heartbeat': (data: {
    platformId: PlatformType;
    timestamp: number;
  }) => void;

  // 消息分发
  'message:send': (data: {
    content: string;
    platforms: PlatformType[];
    mode: 'new' | 'continue';
    files?: File[];
  }) => Promise<{ messageId: string }>;

  'message:cancel': (data: {
    messageId: string;
    platformId?: PlatformType;
  }) => Promise<void>;

  // 响应流
  'response:chunk': (data: {
    messageId: string;
    platformId: PlatformType;
    chunk: string;
    isComplete?: boolean;
  }) => void;

  'response:error': (data: {
    messageId: string;
    platformId: PlatformType;
    error: ErrorInfo;
  }) => void;

  // 状态更新
  'state:update': (data: {
    messageId: string;
    platformId: PlatformType;
    state: MessageState;
  }) => void;

  // 工作台同步
  'workspace:sync': () => WorkspaceState;

  'workspace:platform-config': (data: {
    platforms: PlatformConfig[];
  }) => void;
}

// 导出消息方法
export const { sendMessage, onMessage } = defineExtensionMessaging<ProtocolMap>();
```

### 3.2 Background脚本消息处理

```typescript
// entrypoints/background/message-handlers.ts
import { onMessage } from '@/lib/messaging/protocol';
import { ConnectionManager } from '@/lib/platforms/connection-manager';
import { MessageDispatcher } from '@/lib/messaging/dispatcher';

export class BackgroundMessageHandler {
  constructor(
    private connectionManager: ConnectionManager,
    private dispatcher: MessageDispatcher
  ) {
    this.setupHandlers();
  }

  private setupHandlers() {
    // 连接管理
    onMessage('connection:establish', async (message) => {
      const { platformId } = message.data;
      return await this.connectionManager.establish(platformId);
    });

    onMessage('connection:disconnect', async (message) => {
      const { platformId } = message.data;
      await this.connectionManager.disconnect(platformId);
    });

    onMessage('connection:status', (message) => {
      const { platformId } = message.data;
      return this.connectionManager.getStatus(platformId);
    });

    // 消息分发
    onMessage('message:send', async (message) => {
      const { content, platforms, mode, files } = message.data;
      const messageId = await this.dispatcher.broadcast({
        content,
        platforms,
        mode,
        files
      });
      return { messageId };
    });

    onMessage('message:cancel', async (message) => {
      const { messageId, platformId } = message.data;
      if (platformId) {
        await this.dispatcher.cancelPlatform(messageId, platformId);
      } else {
        await this.dispatcher.cancelAll(messageId);
      }
    });

    // 工作台同步
    onMessage('workspace:sync', () => {
      return this.getWorkspaceState();
    });
  }

  private getWorkspaceState(): WorkspaceState {
    return {
      connections: this.connectionManager.getAllConnections(),
      activeMessages: this.dispatcher.getActiveMessages(),
      config: this.getConfig()
    };
  }
}
```

### 3.3 Content Script通信

```typescript
// entrypoints/content/index.ts
import { defineContentScript } from 'wxt/sandbox';
import { sendMessage } from '@/lib/messaging/protocol';
import { PlatformAdapter } from './adapters/base';
import { detectPlatform } from '@/utils/platform-detector';

export default defineContentScript({
  matches: [
    'https://chat.openai.com/*',
    'https://claude.ai/*',
    'https://gemini.google.com/*'
  ],

  async main(ctx) {
    console.log('OmniChat Content Script Loaded');

    // 检测当前平台
    const platform = detectPlatform(window.location.href);
    if (!platform) return;

    // 动态加载适配器
    const adapter = await loadAdapter(platform);

    // 建立连接
    const result = await sendMessage('connection:establish', {
      platformId: platform
    });

    if (result.success) {
      // 初始化适配器
      await adapter.initialize();

      // 设置消息监听
      adapter.onResponse((chunk) => {
        sendMessage('response:chunk', {
          messageId: adapter.currentMessageId,
          platformId: platform,
          chunk: chunk.content,
          isComplete: chunk.isComplete
        });
      });

      // 心跳保持
      ctx.setInterval(() => {
        sendMessage('connection:heartbeat', {
          platformId: platform,
          timestamp: Date.now()
        });
      }, 5000);
    }
  }
});

// 动态加载平台适配器
async function loadAdapter(platform: PlatformType): Promise<PlatformAdapter> {
  switch (platform) {
    case 'chatgpt':
      const { ChatGPTAdapter } = await import('./adapters/chatgpt');
      return new ChatGPTAdapter();
    case 'claude':
      const { ClaudeAdapter } = await import('./adapters/claude');
      return new ClaudeAdapter();
    case 'gemini':
      const { GeminiAdapter } = await import('./adapters/gemini');
      return new GeminiAdapter();
    default:
      throw new Error(`Unsupported platform: ${platform}`);
  }
}
```

## 4. Vue组件架构

### 4.1 工作台主界面

```vue
<!-- entrypoints/omnichat.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OmniChat 工作台</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="./omnichat/main.ts"></script>
</body>
</html>
```

```typescript
// entrypoints/omnichat/main.ts
import { createApp } from 'vue';
import { createPinia } from 'pinia';
import App from './App.vue';
import '@/assets/styles/global.css';

const app = createApp(App);
const pinia = createPinia();

app.use(pinia);
app.mount('#app');
```

```vue
<!-- entrypoints/omnichat/App.vue -->
<template>
  <div class="omnichat-workspace">
    <!-- 侧边栏：平台管理 -->
    <PlatformSidebar
      v-model:collapsed="sidebarCollapsed"
      :platforms="platforms"
      @connect="handleConnect"
      @disconnect="handleDisconnect"
    />

    <!-- 主内容区 -->
    <main class="workspace-main">
      <!-- 工具栏 -->
      <WorkspaceToolbar
        :connected-count="connectedPlatforms.length"
        :view-mode="viewMode"
        @view-change="viewMode = $event"
        @cancel-all="handleCancelAll"
      />

      <!-- 输入区域 -->
      <MessageInput
        v-model="messageContent"
        :sending="isSending"
        :mode="broadcastMode"
        @send="handleSend"
        @mode-change="broadcastMode = $event"
        @attach-files="handleAttachFiles"
      />

      <!-- 响应展示区 -->
      <ResponseGrid
        :responses="responses"
        :view-mode="viewMode"
        :loading-states="loadingStates"
        @cancel="handleCancelPlatform"
        @retry="handleRetryPlatform"
        @copy="handleCopyResponse"
      />
    </main>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { useWorkspaceStore } from '@/stores/workspace';
import { sendMessage } from '@/lib/messaging/protocol';
import PlatformSidebar from '@/components/workspace/PlatformSidebar.vue';
import WorkspaceToolbar from '@/components/workspace/WorkspaceToolbar.vue';
import MessageInput from '@/components/workspace/MessageInput.vue';
import ResponseGrid from '@/components/workspace/ResponseGrid.vue';

// 状态管理
const store = useWorkspaceStore();
const sidebarCollapsed = ref(false);
const messageContent = ref('');
const broadcastMode = ref<'new' | 'continue'>('new');
const viewMode = ref<ViewMode>('grid');
const isSending = ref(false);

// 计算属性
const platforms = computed(() => store.platforms);
const connectedPlatforms = computed(() =>
  store.platforms.filter(p => p.connectionState === 'connected')
);
const responses = computed(() => store.currentResponses);
const loadingStates = computed(() => store.loadingStates);

// 生命周期
onMounted(async () => {
  // 同步工作台状态
  const state = await sendMessage('workspace:sync');
  store.initializeState(state);
});

// 方法
async function handleConnect(platformId: PlatformType) {
  const result = await sendMessage('connection:establish', { platformId });
  if (result.success) {
    store.updatePlatformConnection(platformId, 'connected');
  }
}

async function handleDisconnect(platformId: PlatformType) {
  await sendMessage('connection:disconnect', { platformId });
  store.updatePlatformConnection(platformId, 'disconnected');
}

async function handleSend() {
  if (!messageContent.value.trim() || connectedPlatforms.value.length === 0) {
    return;
  }

  isSending.value = true;

  try {
    const { messageId } = await sendMessage('message:send', {
      content: messageContent.value,
      platforms: connectedPlatforms.value.map(p => p.id),
      mode: broadcastMode.value,
      files: store.attachedFiles
    });

    store.startNewMessage(messageId, messageContent.value);
    messageContent.value = '';
    store.clearAttachedFiles();
  } catch (error) {
    console.error('发送失败:', error);
  } finally {
    isSending.value = false;
  }
}

async function handleCancelAll() {
  if (store.currentMessageId) {
    await sendMessage('message:cancel', {
      messageId: store.currentMessageId
    });
  }
}

async function handleCancelPlatform(platformId: PlatformType) {
  if (store.currentMessageId) {
    await sendMessage('message:cancel', {
      messageId: store.currentMessageId,
      platformId
    });
  }
}

async function handleRetryPlatform(platformId: PlatformType) {
  // 重试逻辑
  const lastMessage = store.getLastMessage();
  if (lastMessage) {
    const { messageId } = await sendMessage('message:send', {
      content: lastMessage.content,
      platforms: [platformId],
      mode: 'new'
    });
    store.retryPlatform(messageId, platformId);
  }
}

function handleCopyResponse(platformId: PlatformType) {
  const response = store.getResponse(platformId);
  if (response) {
    navigator.clipboard.writeText(response.content);
  }
}

function handleAttachFiles(files: File[]) {
  store.setAttachedFiles(files);
}
</script>

<style scoped>
.omnichat-workspace {
  display: flex;
  height: 100vh;
  background: var(--bg-primary);
}

.workspace-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
</style>
```

### 4.2 Pinia状态管理

```typescript
// stores/workspace.ts
import { defineStore } from 'pinia';
import { onMessage } from '@/lib/messaging/protocol';

interface WorkspaceState {
  platforms: PlatformInfo[];
  currentMessageId: string | null;
  currentResponses: Map<PlatformType, ResponseData>;
  loadingStates: Map<PlatformType, MessageState>;
  messageHistory: Message[];
  attachedFiles: File[];
}

export const useWorkspaceStore = defineStore('workspace', {
  state: (): WorkspaceState => ({
    platforms: [],
    currentMessageId: null,
    currentResponses: new Map(),
    loadingStates: new Map(),
    messageHistory: [],
    attachedFiles: []
  }),

  getters: {
    connectedPlatforms: (state) => {
      return state.platforms.filter(p => p.connectionState === 'connected');
    },

    hasActiveRequests: (state) => {
      return Array.from(state.loadingStates.values()).some(
        state => state === 'sending' || state === 'receiving'
      );
    }
  },

  actions: {
    initializeState(state: WorkspaceState) {
      this.platforms = state.platforms;
      this.setupMessageListeners();
    },

    setupMessageListeners() {
      // 监听响应块
      onMessage('response:chunk', (message) => {
        const { messageId, platformId, chunk, isComplete } = message.data;

        if (messageId === this.currentMessageId) {
          const current = this.currentResponses.get(platformId) || { content: '' };
          current.content += chunk;

          if (isComplete) {
            current.isComplete = true;
            this.loadingStates.set(platformId, 'completed');
          }

          this.currentResponses.set(platformId, current);
        }
      });

      // 监听状态更新
      onMessage('state:update', (message) => {
        const { messageId, platformId, state } = message.data;

        if (messageId === this.currentMessageId) {
          this.loadingStates.set(platformId, state);
        }
      });

      // 监听错误
      onMessage('response:error', (message) => {
        const { messageId, platformId, error } = message.data;

        if (messageId === this.currentMessageId) {
          this.loadingStates.set(platformId, 'failed');
          this.currentResponses.set(platformId, {
            content: '',
            error: error.message,
            isComplete: true
          });
        }
      });
    },

    startNewMessage(messageId: string, content: string) {
      this.currentMessageId = messageId;
      this.currentResponses.clear();
      this.loadingStates.clear();

      // 初始化所有连接平台的状态
      this.connectedPlatforms.forEach(platform => {
        this.loadingStates.set(platform.id, 'sending');
      });

      // 添加到历史
      this.messageHistory.push({
        id: messageId,
        content,
        timestamp: Date.now(),
        responses: new Map()
      });
    },

    updatePlatformConnection(platformId: PlatformType, state: ConnectionState) {
      const platform = this.platforms.find(p => p.id === platformId);
      if (platform) {
        platform.connectionState = state;
      }
    },

    getResponse(platformId: PlatformType): ResponseData | null {
      return this.currentResponses.get(platformId) || null;
    },

    getLastMessage(): Message | null {
      return this.messageHistory[this.messageHistory.length - 1] || null;
    },

    setAttachedFiles(files: File[]) {
      this.attachedFiles = files;
    },

    clearAttachedFiles() {
      this.attachedFiles = [];
    }
  }
});
```

## 5. 平台适配器实现

### 5.1 基础适配器类

```typescript
// entrypoints/content/adapters/base.ts
export abstract class PlatformAdapter {
  protected platformId: PlatformType;
  protected selectors: PlatformSelectors;
  public currentMessageId: string | null = null;
  protected responseCallback: ((chunk: ResponseChunk) => void) | null = null;
  protected observer: MutationObserver | null = null;

  constructor(platformId: PlatformType, selectors: PlatformSelectors) {
    this.platformId = platformId;
    this.selectors = selectors;
  }

  abstract async initialize(): Promise<void>;
  abstract async sendMessage(content: string, mode: SendMode): Promise<void>;
  abstract async attachFiles(files: File[]): Promise<void>;
  abstract async cancelGeneration(): Promise<void>;
  abstract async detectResponseComplete(): Promise<boolean>;

  // 通用方法
  onResponse(callback: (chunk: ResponseChunk) => void) {
    this.responseCallback = callback;
  }

  protected async waitForElement(
    selector: string,
    timeout = 5000
  ): Promise<Element> {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();

      const check = () => {
        const element = document.querySelector(selector);

        if (element) {
          resolve(element);
        } else if (Date.now() - startTime > timeout) {
          reject(new Error(`Element not found: ${selector}`));
        } else {
          requestAnimationFrame(check);
        }
      };

      check();
    });
  }

  protected watchForResponse() {
    if (this.observer) {
      this.observer.disconnect();
    }

    this.observer = new MutationObserver(async (mutations) => {
      const responseText = this.extractResponseText(mutations);

      if (responseText && this.responseCallback) {
        const isComplete = await this.detectResponseComplete();

        this.responseCallback({
          content: responseText,
          isComplete,
          timestamp: Date.now()
        });
      }
    });

    const container = document.querySelector(this.selectors.responseContainer);
    if (container) {
      this.observer.observe(container, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }
  }

  protected abstract extractResponseText(mutations: MutationRecord[]): string;

  protected async simulateTyping(
    element: HTMLElement,
    text: string
  ): Promise<void> {
    // 清空现有内容
    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
      element.value = '';
    } else {
      element.textContent = '';
    }

    // 聚焦元素
    element.focus();

    // 使用Input事件模拟输入
    const inputEvent = new InputEvent('input', {
      data: text,
      inputType: 'insertText',
      bubbles: true,
      cancelable: true
    });

    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
      element.value = text;
    } else {
      element.textContent = text;
    }

    element.dispatchEvent(inputEvent);

    // 触发change事件
    element.dispatchEvent(new Event('change', { bubbles: true }));
  }

  protected async clickElement(element: HTMLElement): Promise<void> {
    // 滚动到元素
    element.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // 等待滚动完成
    await new Promise(resolve => setTimeout(resolve, 300));

    // 模拟点击
    element.click();

    // 备用方案：如果click不生效，使用事件
    const clickEvent = new MouseEvent('click', {
      view: window,
      bubbles: true,
      cancelable: true
    });
    element.dispatchEvent(clickEvent);
  }

  cleanup() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    this.responseCallback = null;
    this.currentMessageId = null;
  }
}
```

### 5.2 ChatGPT适配器实现

```typescript
// entrypoints/content/adapters/chatgpt.ts
import { PlatformAdapter } from './base';

export class ChatGPTAdapter extends PlatformAdapter {
  constructor() {
    super('chatgpt', {
      inputBox: '#prompt-textarea',
      sendButton: '[data-testid="send-button"]',
      newChatButton: 'nav a[href="/"]',
      responseContainer: '[data-message-author-role="assistant"]',
      responseContent: '.markdown',
      stopButton: 'button[aria-label="Stop generating"]',
      regenerateButton: 'button:contains("Regenerate")',
      fileInput: 'input[type="file"]',
      loadingIndicator: '.result-streaming'
    });
  }

  async initialize(): Promise<void> {
    console.log('Initializing ChatGPT Adapter');

    // 等待页面加载完成
    await this.waitForElement(this.selectors.inputBox);

    // 开始监听响应
    this.watchForResponse();
  }

  async sendMessage(content: string, mode: SendMode): Promise<void> {
    // 如果是新对话模式，先创建新对话
    if (mode === 'new') {
      await this.startNewChat();
    }

    // 获取输入框
    const inputBox = await this.waitForElement(this.selectors.inputBox) as HTMLTextAreaElement;

    // 输入消息
    await this.simulateTyping(inputBox, content);

    // 等待发送按钮可用
    await this.waitForElement(this.selectors.sendButton);

    // 点击发送
    const sendButton = document.querySelector(this.selectors.sendButton) as HTMLButtonElement;
    await this.clickElement(sendButton);
  }

  private async startNewChat(): Promise<void> {
    const newChatButton = document.querySelector(this.selectors.newChatButton) as HTMLElement;

    if (newChatButton) {
      await this.clickElement(newChatButton);
      // 等待新对话创建
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  async attachFiles(files: File[]): Promise<void> {
    const fileInput = document.querySelector(this.selectors.fileInput) as HTMLInputElement;

    if (!fileInput) {
      throw new Error('File input not found');
    }

    // 创建DataTransfer对象来设置文件
    const dataTransfer = new DataTransfer();
    files.forEach(file => dataTransfer.items.add(file));

    fileInput.files = dataTransfer.files;

    // 触发change事件
    fileInput.dispatchEvent(new Event('change', { bubbles: true }));
  }

  async cancelGeneration(): Promise<void> {
    const stopButton = document.querySelector(this.selectors.stopButton) as HTMLButtonElement;

    if (stopButton && !stopButton.disabled) {
      await this.clickElement(stopButton);
    }
  }

  async detectResponseComplete(): Promise<boolean> {
    // 检查是否还在流式输出中
    const loadingIndicator = document.querySelector(this.selectors.loadingIndicator);
    const stopButton = document.querySelector(this.selectors.stopButton);

    return !loadingIndicator && !stopButton;
  }

  protected extractResponseText(mutations: MutationRecord[]): string {
    // 获取最新的助手响应
    const responseElements = document.querySelectorAll(this.selectors.responseContainer);

    if (responseElements.length === 0) return '';

    const latestResponse = responseElements[responseElements.length - 1];
    const contentElement = latestResponse.querySelector(this.selectors.responseContent);

    return contentElement?.textContent || '';
  }
}

### 5.3 Claude适配器实现

```typescript
// entrypoints/content/adapters/claude.ts
import { PlatformAdapter } from './base';

export class ClaudeAdapter extends PlatformAdapter {
  constructor() {
    super('claude', {
      inputBox: 'div[contenteditable="true"]',
      sendButton: 'button[aria-label*="Send"]',
      newChatButton: 'button[aria-label*="New chat"]',
      responseContainer: 'div[data-test-id="message-assistant"]',
      responseContent: '.prose',
      stopButton: 'button[aria-label*="Stop"]',
      regenerateButton: 'button[aria-label*="Retry"]',
      fileInput: 'input[type="file"]',
      loadingIndicator: '[data-test-id="loading-indicator"]'
    });
  }

  async initialize(): Promise<void> {
    console.log('Initializing Claude Adapter');
    await this.waitForElement(this.selectors.inputBox);
    this.watchForResponse();
  }

  async sendMessage(content: string, mode: SendMode): Promise<void> {
    if (mode === 'new') {
      await this.startNewChat();
    }

    const inputBox = await this.waitForElement(this.selectors.inputBox) as HTMLElement;

    // Claude使用contenteditable，需要特殊处理
    inputBox.focus();
    inputBox.textContent = content;

    // 触发输入事件
    inputBox.dispatchEvent(new InputEvent('input', {
      data: content,
      inputType: 'insertText',
      bubbles: true
    }));

    // 发送消息
    const sendButton = await this.waitForElement(this.selectors.sendButton) as HTMLButtonElement;
    await this.clickElement(sendButton);
  }

  private async startNewChat(): Promise<void> {
    const newChatButton = document.querySelector(this.selectors.newChatButton) as HTMLElement;
    if (newChatButton) {
      await this.clickElement(newChatButton);
      await new Promise(resolve => setTimeout(resolve, 800));
    }
  }

  async attachFiles(files: File[]): Promise<void> {
    // Claude的文件上传逻辑
    const fileInput = document.querySelector(this.selectors.fileInput) as HTMLInputElement;
    if (!fileInput) throw new Error('File input not found');

    const dataTransfer = new DataTransfer();
    files.forEach(file => dataTransfer.items.add(file));
    fileInput.files = dataTransfer.files;
    fileInput.dispatchEvent(new Event('change', { bubbles: true }));
  }

  async cancelGeneration(): Promise<void> {
    const stopButton = document.querySelector(this.selectors.stopButton) as HTMLButtonElement;
    if (stopButton) {
      await this.clickElement(stopButton);
    }
  }

  async detectResponseComplete(): Promise<boolean> {
    const loadingIndicator = document.querySelector(this.selectors.loadingIndicator);
    return !loadingIndicator;
  }

  protected extractResponseText(mutations: MutationRecord[]): string {
    const responseElements = document.querySelectorAll(this.selectors.responseContainer);
    if (responseElements.length === 0) return '';

    const latestResponse = responseElements[responseElements.length - 1];
    const contentElement = latestResponse.querySelector(this.selectors.responseContent);

    return contentElement?.textContent || '';
  }
}
```

## 6. 存储管理（使用@webext-core/storage）

### 6.1 存储配置

```typescript
// lib/storage/index.ts
import { defineExtensionStorage } from '@webext-core/storage';

// 定义存储数据结构
interface StorageData {
  // 用户配置
  userConfig: {
    enabledPlatforms: PlatformType[];
    defaultMode: 'new' | 'continue';
    theme: 'light' | 'dark' | 'auto';
    viewMode: ViewMode;
    autoSave: boolean;
  };

  // 会话历史
  sessions: SessionData[];

  // 平台配置
  platformSettings: Record<PlatformType, PlatformSettings>;

  // 统计数据
  statistics: {
    totalMessages: number;
    platformUsage: Record<PlatformType, number>;
    lastUsed: number;
  };
}

// 创建存储实例
export const storage = defineExtensionStorage<StorageData>({
  // 默认值
  userConfig: {
    enabledPlatforms: ['chatgpt', 'claude', 'gemini'],
    defaultMode: 'new',
    theme: 'auto',
    viewMode: 'grid',
    autoSave: true
  },

  sessions: [],

  platformSettings: {},

  statistics: {
    totalMessages: 0,
    platformUsage: {},
    lastUsed: Date.now()
  }
});

// 会话管理
export class SessionManager {
  private readonly MAX_SESSIONS = 100;
  private readonly SESSION_RETENTION_DAYS = 30;

  async saveSession(session: SessionData): Promise<void> {
    const sessions = await storage.sessions.getValue();

    // 添加新会话
    sessions.unshift(session);

    // 限制数量
    if (sessions.length > this.MAX_SESSIONS) {
      sessions.length = this.MAX_SESSIONS;
    }

    // 清理过期会话
    const cutoffTime = Date.now() - (this.SESSION_RETENTION_DAYS * 24 * 60 * 60 * 1000);
    const validSessions = sessions.filter(s => s.timestamp > cutoffTime);

    await storage.sessions.setValue(validSessions);
  }

  async getRecentSessions(limit = 10): Promise<SessionData[]> {
    const sessions = await storage.sessions.getValue();
    return sessions.slice(0, limit);
  }

  async searchSessions(query: string): Promise<SessionData[]> {
    const sessions = await storage.sessions.getValue();
    const lowerQuery = query.toLowerCase();

    return sessions.filter(session =>
      session.content.toLowerCase().includes(lowerQuery) ||
      session.responses.some(r => r.content.toLowerCase().includes(lowerQuery))
    );
  }

  async deleteSession(sessionId: string): Promise<void> {
    const sessions = await storage.sessions.getValue();
    const filtered = sessions.filter(s => s.id !== sessionId);
    await storage.sessions.setValue(filtered);
  }

  async exportSessions(): Promise<string> {
    const sessions = await storage.sessions.getValue();
    return JSON.stringify(sessions, null, 2);
  }

  async importSessions(json: string): Promise<void> {
    try {
      const imported = JSON.parse(json) as SessionData[];
      const current = await storage.sessions.getValue();

      // 合并导入的会话
      const merged = [...imported, ...current];

      // 去重
      const unique = Array.from(
        new Map(merged.map(s => [s.id, s])).values()
      );

      await storage.sessions.setValue(unique);
    } catch (error) {
      throw new Error('Invalid session data format');
    }
  }
}
```

### 6.2 配置管理

```typescript
// lib/storage/config-manager.ts
import { storage } from './index';

export class ConfigManager {
  // 获取用户配置
  async getUserConfig() {
    return await storage.userConfig.getValue();
  }

  // 更新配置项
  async updateConfig(key: keyof UserConfig, value: any) {
    const config = await storage.userConfig.getValue();
    config[key] = value;
    await storage.userConfig.setValue(config);
  }

  // 获取启用的平台
  async getEnabledPlatforms(): Promise<PlatformType[]> {
    const config = await storage.userConfig.getValue();
    return config.enabledPlatforms;
  }

  // 切换平台启用状态
  async togglePlatform(platformId: PlatformType, enabled: boolean) {
    const config = await storage.userConfig.getValue();

    if (enabled && !config.enabledPlatforms.includes(platformId)) {
      config.enabledPlatforms.push(platformId);
    } else if (!enabled) {
      config.enabledPlatforms = config.enabledPlatforms.filter(p => p !== platformId);
    }

    await storage.userConfig.setValue(config);
  }

  // 获取平台设置
  async getPlatformSettings(platformId: PlatformType): Promise<PlatformSettings> {
    const settings = await storage.platformSettings.getValue();
    return settings[platformId] || this.getDefaultSettings(platformId);
  }

  // 更新平台设置
  async updatePlatformSettings(
    platformId: PlatformType,
    settings: Partial<PlatformSettings>
  ) {
    const allSettings = await storage.platformSettings.getValue();
    allSettings[platformId] = {
      ...allSettings[platformId],
      ...settings
    };
    await storage.platformSettings.setValue(allSettings);
  }

  private getDefaultSettings(platformId: PlatformType): PlatformSettings {
    return {
      autoReconnect: true,
      timeout: 30000,
      retryAttempts: 3,
      customPromptPrefix: '',
      customPromptSuffix: ''
    };
  }
}
```

## 7. 开发与调试

### 7.1 开发命令

```json
// package.json
{
  "name": "omnichat",
  "version": "1.0.0",
  "scripts": {
    "dev": "wxt",
    "dev:firefox": "wxt --browser firefox",
    "build": "wxt build",
    "build:firefox": "wxt build --browser firefox",
    "zip": "wxt zip",
    "postinstall": "wxt prepare",
    "type-check": "vue-tsc --noEmit",
    "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts",
    "test": "vitest",
    "test:ui": "vitest --ui"
  },
  "dependencies": {
    "@webext-core/messaging": "^1.4.0",
    "@webext-core/storage": "^1.3.1",
    "pinia": "^2.1.7",
    "vue": "^3.4.21"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.4",
    "@vue/test-utils": "^2.4.5",
    "@wxt-dev/module-vue": "^1.0.0",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.57.0",
    "eslint-plugin-vue": "^9.23.0",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.3",
    "typescript": "^5.4.3",
    "vite": "^5.2.8",
    "vitest": "^1.4.0",
    "vue-tsc": "^2.0.7",
    "wxt": "^0.17.0"
  }
}
```

### 7.2 开发工具集成

```typescript
// utils/dev-tools.ts
export class DevTools {
  private static isDev = import.meta.env.DEV;

  // 消息调试
  static logMessage(type: string, data: any) {
    if (!this.isDev) return;

    console.group(`🔍 OmniChat Message: ${type}`);
    console.log('Timestamp:', new Date().toISOString());
    console.log('Data:', data);
    console.trace('Stack Trace');
    console.groupEnd();
  }

  // 性能监控
  static measurePerformance(name: string, fn: () => any) {
    if (!this.isDev) return fn();

    const start = performance.now();
    const result = fn();
    const end = performance.now();

    console.log(`⚡ Performance: ${name} took ${(end - start).toFixed(2)}ms`);

    return result;
  }

  // 模拟延迟
  static async simulateDelay(ms: number) {
    if (this.isDev) {
      await new Promise(resolve => setTimeout(resolve, ms));
    }
  }

  // 状态检查器
  static checkState() {
    if (!this.isDev) return;

    // 检查所有标签页的Content Script状态
    browser.tabs.query({}).then(tabs => {
      tabs.forEach(tab => {
        if (tab.id) {
          browser.tabs.sendMessage(tab.id, { type: 'PING' })
            .then(() => console.log(`✅ Tab ${tab.id} responsive`))
            .catch(() => console.log(`❌ Tab ${tab.id} not responsive`));
        }
      });
    });
  }

  // 错误报告
  static reportError(error: Error, context?: any) {
    console.error('❌ OmniChat Error:', error);

    if (context) {
      console.error('Context:', context);
    }

    if (this.isDev) {
      // 开发模式下显示通知
      browser.notifications.create({
        type: 'basic',
        iconUrl: '/icons/icon-48.png',
        title: 'OmniChat Error',
        message: error.message
      });
    }
  }
}
```

## 8. 测试策略

### 8.1 单元测试示例

```typescript
// tests/unit/message-dispatcher.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { MessageDispatcher } from '@/lib/messaging/dispatcher';
import { ConnectionManager } from '@/lib/platforms/connection-manager';

describe('MessageDispatcher', () => {
  let dispatcher: MessageDispatcher;
  let connectionManager: ConnectionManager;

  beforeEach(() => {
    connectionManager = new ConnectionManager();
    dispatcher = new MessageDispatcher(connectionManager);
  });

  it('should broadcast message to all connected platforms', async () => {
    // Mock连接
    vi.spyOn(connectionManager, 'getConnectedPlatforms').mockReturnValue([
      { id: 'chatgpt', state: 'connected' },
      { id: 'claude', state: 'connected' }
    ]);

    const messageId = await dispatcher.broadcast({
      content: 'Test message',
      platforms: ['chatgpt', 'claude'],
      mode: 'new'
    });

    expect(messageId).toBeDefined();
    expect(dispatcher.getActiveMessages()).toContain(messageId);
  });

  it('should handle platform-specific cancellation', async () => {
    const messageId = 'test-message-id';

    await dispatcher.cancelPlatform(messageId, 'chatgpt');

    // 验证只有ChatGPT被取消
    const state = dispatcher.getPlatformState(messageId, 'chatgpt');
    expect(state).toBe('cancelled');
  });

  it('should retry failed messages', async () => {
    const messageId = 'test-message-id';

    // 模拟失败
    dispatcher.updateState(messageId, 'chatgpt', 'failed');

    // 重试
    await dispatcher.retryPlatform(messageId, 'chatgpt');

    // 验证状态更新
    const state = dispatcher.getPlatformState(messageId, 'chatgpt');
    expect(state).toBe('sending');
  });
});
```

### 8.2 组件测试

```typescript
// tests/components/MessageInput.test.ts
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import MessageInput from '@/components/workspace/MessageInput.vue';

describe('MessageInput Component', () => {
  it('should emit send event with message content', async () => {
    const wrapper = mount(MessageInput, {
      props: {
        modelValue: '',
        sending: false,
        mode: 'new'
      }
    });

    // 输入消息
    const textarea = wrapper.find('textarea');
    await textarea.setValue('Test message');

    // 点击发送按钮
    const sendButton = wrapper.find('[data-test="send-button"]');
    await sendButton.trigger('click');

    // 验证事件
    expect(wrapper.emitted('send')).toBeTruthy();
    expect(wrapper.emitted('update:modelValue')?.[0]).toEqual(['Test message']);
  });

  it('should disable send button when sending', () => {
    const wrapper = mount(MessageInput, {
      props: {
        modelValue: 'Test',
        sending: true,
        mode: 'new'
      }
    });

    const sendButton = wrapper.find('[data-test="send-button"]');
    expect(sendButton.attributes('disabled')).toBeDefined();
  });

  it('should handle file attachments', async () => {
    const wrapper = mount(MessageInput);

    const file = new File(['test'], 'test.txt', { type: 'text/plain' });
    const fileInput = wrapper.find('input[type="file"]');

    // 模拟文件选择
    Object.defineProperty(fileInput.element, 'files', {
      value: [file],
      writable: false
    });

    await fileInput.trigger('change');

    // 验证文件附件事件
    expect(wrapper.emitted('attach-files')).toBeTruthy();
    expect(wrapper.emitted('attach-files')?.[0]?.[0]).toContainEqual(file);
  });
});
```

## 9. 部署与发布

### 9.1 构建配置

```typescript
// wxt.config.ts (生产构建配置)
import { defineConfig } from 'wxt';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  vite: () => ({
    plugins: [vue()],
    build: {
      // 生产优化
      minify: 'terser',
      terserOptions: {
        compress: {
          drop_console: true,
          drop_debugger: true
        }
      },
      rollupOptions: {
        output: {
          manualChunks: {
            'vendor-vue': ['vue', 'pinia'],
            'vendor-messaging': ['@webext-core/messaging', '@webext-core/storage'],
            'vendor-ui': ['@headlessui/vue', '@heroicons/vue']
          }
        }
      }
    }
  }),

  // 生产环境manifest
  manifest: (env) => ({
    ...baseManifest,
    version: process.env.npm_package_version,
    version_name: env.mode === 'production' ? undefined : 'Dev Build',

    // 生产环境CSP
    content_security_policy: {
      extension_pages: env.mode === 'production'
        ? "script-src 'self'; object-src 'self'"
        : "script-src 'self' 'unsafe-eval'; object-src 'self'"
    }
  }),

  // 自动发布配置
  publishConfig: {
    chrome: {
      clientId: process.env.CHROME_CLIENT_ID,
      clientSecret: process.env.CHROME_CLIENT_SECRET,
      refreshToken: process.env.CHROME_REFRESH_TOKEN,
      extensionId: process.env.CHROME_EXTENSION_ID
    },
    firefox: {
      jwtIssuer: process.env.FIREFOX_JWT_ISSUER,
      jwtSecret: process.env.FIREFOX_JWT_SECRET,
      extensionId: process.env.FIREFOX_EXTENSION_ID
    }
  }
});
```

### 9.2 发布流程

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build extension
        run: |
          npm run build
          npm run build:firefox

      - name: Package extensions
        run: npm run zip

      - name: Upload to Chrome Web Store
        if: success()
        run: npx wxt publish:chrome
        env:
          CHROME_CLIENT_ID: ${{ secrets.CHROME_CLIENT_ID }}
          CHROME_CLIENT_SECRET: ${{ secrets.CHROME_CLIENT_SECRET }}
          CHROME_REFRESH_TOKEN: ${{ secrets.CHROME_REFRESH_TOKEN }}

      - name: Upload to Firefox Add-ons
        if: success()
        run: npx wxt publish:firefox
        env:
          FIREFOX_JWT_ISSUER: ${{ secrets.FIREFOX_JWT_ISSUER }}
          FIREFOX_JWT_SECRET: ${{ secrets.FIREFOX_JWT_SECRET }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            .output/*.zip
          draft: false
          prerelease: false
```

## 10. 总结

### 10.1 WXT框架优势

1. **开发体验优秀**
   - HMR支持，实时更新
   - 自动生成manifest
   - TypeScript原生支持
   - 文件路由系统

2. **跨浏览器兼容**
   - 同一代码库支持Chrome/Firefox/Safari
   - 自动处理Manifest V2/V3差异
   - 浏览器特定配置支持

3. **工具链完善**
   - 内置Vite构建
   - 自动打包发布
   - 测试框架集成
   - 开发者工具支持

### 10.2 @webext-core优势

1. **类型安全**
   - 完整的TypeScript类型定义
   - 编译时类型检查
   - IDE智能提示

2. **简化API**
   - 统一的消息传递接口
   - 简化的存储管理
   - 更好的错误处理

3. **跨浏览器支持**
   - 基于webextension-polyfill
   - 自动处理浏览器差异
   - Promise化的API

### 10.3 架构特点

1. **模块化设计**
   - 清晰的模块边界
   - 可独立测试和维护
   - 易于扩展新平台

2. **性能优化**
   - 代码分割
   - 懒加载
   - 虚拟滚动

3. **开发友好**
   - 热重载支持
   - 完善的调试工具
   - 详细的错误信息

通过使用WXT框架和@webext-core/messaging，OmniChat项目能够获得更好的开发体验、更强的类型安全性，以及更简洁的代码结构。这个架构设计充分利用了现代Web扩展开发的最佳实践，为项目的长期维护和扩展奠定了坚实的基础。
