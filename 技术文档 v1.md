# OmniChat WXTæŠ€æœ¯æ¶æ„æ–‡æ¡£ v1

| **æ–‡æ¡£ç‰ˆæœ¬** | **æ—¥æœŸ** | **ä½œè€…** | **çŠ¶æ€** | **ä¿®è®¢è¯´æ˜** |
| :--- | :--- | :--- | :--- | :--- |
| 3.0 | 2025å¹´8æœˆ27æ—¥ | Claude | æŠ€æœ¯æ¶æ„é‡æ„ | åŸºäºWXTæ¡†æ¶å’Œ@webext-core/messagingé‡æ–°è®¾è®¡æ¶æ„ |

## 1. æŠ€æœ¯æ ˆæ¦‚è§ˆ

### 1.1 æ ¸å¿ƒæŠ€æœ¯é€‰å‹

| æŠ€æœ¯ | ç‰ˆæœ¬ | ç”¨é€” | è¯´æ˜ |
|------|------|------|------|
| **WXT** | Latest | æ‰©å±•æ¡†æ¶ | æä¾›HMRã€è‡ªåŠ¨manifestç”Ÿæˆã€è·¨æµè§ˆå™¨æ”¯æŒ |
| **Vue.js** | 3.x | UIæ¡†æ¶ | å“åº”å¼ç»„ä»¶ï¼Œç”¨äºpopupå’Œç‹¬ç«‹é¡µé¢ |
| **@webext-core/messaging** | Latest | æ¶ˆæ¯é€šä¿¡ | ç±»å‹å®‰å…¨çš„æ¶ˆæ¯ä¼ é€’æ¡†æ¶ |
| **@webext-core/storage** | Latest | å­˜å‚¨ç®¡ç† | ç±»å‹å®‰å…¨çš„å­˜å‚¨APIå°è£… |
| **TypeScript** | 5.x | ç±»å‹ç³»ç»Ÿ | æä¾›ç±»å‹å®‰å…¨å’Œæ›´å¥½çš„IDEæ”¯æŒ |
| **Vite** | 5.x | æ„å»ºå·¥å…· | WXTå†…ç½®ï¼Œæä¾›å¿«é€Ÿçš„HMR |
| **Tailwind CSS** | 3.x | æ ·å¼æ¡†æ¶ | åŸå­åŒ–CSSï¼Œå¿«é€Ÿå¼€å‘ |
| **Pinia** | 2.x | çŠ¶æ€ç®¡ç† | Vue3çš„è½»é‡çº§çŠ¶æ€ç®¡ç† |
| **Xpath** | æœ€æ–°ç‰ˆ | å…ƒç´ é€‰æ‹© | ä½¿ç”¨xpathæ¥é€‰æ‹©é¡µé¢å…ƒç´ ï¼Œæä¾›æ›´å¼ºå¤§æ›´é€šç”¨çš„åŠŸèƒ½ |


### 1.2 WXTé¡¹ç›®ç»“æ„

```
omnichat/
â”œâ”€â”€ .wxt/                      # WXTç”Ÿæˆçš„æ–‡ä»¶ï¼ˆè‡ªåŠ¨ï¼‰
â”œâ”€â”€ assets/                    # é™æ€èµ„æº
â”‚   â”œâ”€â”€ icons/                # æ‰©å±•å›¾æ ‡å’Œå¹³å°logo
â”‚   â””â”€â”€ styles/              # å…¨å±€æ ·å¼
â”œâ”€â”€ components/              # Vueç»„ä»¶
â”‚   â”œâ”€â”€ common/             # é€šç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ platform/           # å¹³å°ç›¸å…³ç»„ä»¶
â”‚   â””â”€â”€ workspace/          # å·¥ä½œå°ç»„ä»¶
â”œâ”€â”€ entrypoints/            # WXTå…¥å£ç‚¹ï¼ˆé‡è¦ï¼‰
â”‚   â”œâ”€â”€ background.ts       # åå°è„šæœ¬
â”‚   â”œâ”€â”€ content/           # Content Scripts
â”‚   â”‚   â”œâ”€â”€ index.ts       # é€šç”¨content script
â”‚   â”‚   â””â”€â”€ adapters/      # å¹³å°é€‚é…å™¨
â”‚   â”œâ”€â”€ popup/             # å¼¹çª—ç•Œé¢
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ main.ts
â”‚   â”‚   â””â”€â”€ App.vue
â”‚   â””â”€â”€ omnichat.html      # ç‹¬ç«‹å·¥ä½œå°é¡µé¢
â”œâ”€â”€ lib/                    # æ ¸å¿ƒåº“
â”‚   â”œâ”€â”€ messaging/         # æ¶ˆæ¯ç³»ç»Ÿ
â”‚   â”œâ”€â”€ storage/           # å­˜å‚¨ç®¡ç†
â”‚   â””â”€â”€ platforms/         # å¹³å°é…ç½®
â”œâ”€â”€ public/                # å…¬å…±æ–‡ä»¶
â”œâ”€â”€ utils/                 # å·¥å…·å‡½æ•°
â”œâ”€â”€ wxt.config.ts         # WXTé…ç½®æ–‡ä»¶
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

## 2. WXTé…ç½®ä¸è®¾ç½®

### 2.1 WXTé…ç½®æ–‡ä»¶

```typescript
// wxt.config.ts
import { defineConfig } from 'wxt';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  // ä½¿ç”¨Vueæ’ä»¶
  vite: () => ({
    plugins: [vue()],
  }),

  // Manifesté…ç½®
  manifest: {
    name: 'OmniChat - AIåä½œå·¥ä½œå°',
    description: 'ç»Ÿä¸€çš„å¤šå¹³å°AIäº¤äº’å·¥å…·',
    version: '1.0.0',

    permissions: [
      'storage',
      'tabs',
      'scripting',
      'activeTab'
    ],

    host_permissions: [
      'https://chat.openai.com/*',
      'https://claude.ai/*',
      'https://gemini.google.com/*',
      'https://poe.com/*',
      'https://chat.deepseek.com/*'
    ],

    // æµè§ˆå™¨ç‰¹å®šè®¾ç½®
    browser_specific_settings: {
      gecko: {
        id: 'omnichat@extension.dev',
        strict_min_version: '109.0'
      }
    },

    // åŠ¨ä½œé…ç½®
    action: {
      default_popup: 'popup.html',
      default_icon: {
        16: '/icons/icon-16.png',
        32: '/icons/icon-32.png',
        48: '/icons/icon-48.png',
        128: '/icons/icon-128.png'
      }
    }
  },

  // æ¨¡å—é…ç½®
  modules: [
    '@wxt-dev/module-vue'  // Vueæ”¯æŒæ¨¡å—
  ],

  // å¼€å‘é…ç½®
  runner: {
    startUrls: [
      'https://chat.openai.com',
      'https://claude.ai'
    ]
  },

  // æ„å»ºé…ç½®
  zip: {
    artifactTemplate: 'omnichat-{{version}}-{{browser}}.zip'
  }
});
```

### 2.2 å…¥å£ç‚¹å®šä¹‰

```typescript
// entrypoints/background.ts
import { defineBackground } from 'wxt/sandbox';
import { initializeMessaging } from '@/lib/messaging';
import { ConnectionManager } from '@/lib/platforms/connection-manager';
import { MessageDispatcher } from '@/lib/messaging/dispatcher';

export default defineBackground(() => {
  console.log('OmniChat Background Script Started');

  // åˆå§‹åŒ–æ¶ˆæ¯ç³»ç»Ÿ
  initializeMessaging();

  // åˆå§‹åŒ–è¿æ¥ç®¡ç†å™¨
  const connectionManager = new ConnectionManager();

  // åˆå§‹åŒ–æ¶ˆæ¯åˆ†å‘å™¨
  const dispatcher = new MessageDispatcher(connectionManager);

  // ç›‘å¬æ‰©å±•å®‰è£…
  browser.runtime.onInstalled.addListener(() => {
    console.log('OmniChat installed');
    // æ‰“å¼€å·¥ä½œå°
    browser.tabs.create({
      url: browser.runtime.getURL('/omnichat.html')
    });
  });
});
```

## 3. æ¶ˆæ¯ç³»ç»Ÿæ¶æ„ï¼ˆä½¿ç”¨@webext-core/messagingï¼‰

### 3.1 æ¶ˆæ¯åè®®å®šä¹‰

```typescript
// lib/messaging/protocol.ts
import { defineExtensionMessaging } from '@webext-core/messaging';

// å®šä¹‰æ¶ˆæ¯åè®®æ˜ å°„
export interface ProtocolMap {
  // è¿æ¥ç®¡ç†
  'connection:establish': (data: {
    platformId: PlatformType;
  }) => Promise<ConnectionResult>;

  'connection:disconnect': (data: {
    platformId: PlatformType;
  }) => Promise<void>;

  'connection:status': (data: {
    platformId: PlatformType;
  }) => ConnectionState;

  'connection:heartbeat': (data: {
    platformId: PlatformType;
    timestamp: number;
  }) => void;

  // æ¶ˆæ¯åˆ†å‘
  'message:send': (data: {
    content: string;
    platforms: PlatformType[];
    mode: 'new' | 'continue';
    files?: File[];
  }) => Promise<{ messageId: string }>;

  'message:cancel': (data: {
    messageId: string;
    platformId?: PlatformType;
  }) => Promise<void>;

  // å“åº”æµ
  'response:chunk': (data: {
    messageId: string;
    platformId: PlatformType;
    chunk: string;
    isComplete?: boolean;
  }) => void;

  'response:error': (data: {
    messageId: string;
    platformId: PlatformType;
    error: ErrorInfo;
  }) => void;

  // çŠ¶æ€æ›´æ–°
  'state:update': (data: {
    messageId: string;
    platformId: PlatformType;
    state: MessageState;
  }) => void;

  // å·¥ä½œå°åŒæ­¥
  'workspace:sync': () => WorkspaceState;

  'workspace:platform-config': (data: {
    platforms: PlatformConfig[];
  }) => void;
}

// å¯¼å‡ºæ¶ˆæ¯æ–¹æ³•
export const { sendMessage, onMessage } = defineExtensionMessaging<ProtocolMap>();
```

### 3.2 Backgroundè„šæœ¬æ¶ˆæ¯å¤„ç†

```typescript
// entrypoints/background/message-handlers.ts
import { onMessage } from '@/lib/messaging/protocol';
import { ConnectionManager } from '@/lib/platforms/connection-manager';
import { MessageDispatcher } from '@/lib/messaging/dispatcher';

export class BackgroundMessageHandler {
  constructor(
    private connectionManager: ConnectionManager,
    private dispatcher: MessageDispatcher
  ) {
    this.setupHandlers();
  }

  private setupHandlers() {
    // è¿æ¥ç®¡ç†
    onMessage('connection:establish', async (message) => {
      const { platformId } = message.data;
      return await this.connectionManager.establish(platformId);
    });

    onMessage('connection:disconnect', async (message) => {
      const { platformId } = message.data;
      await this.connectionManager.disconnect(platformId);
    });

    onMessage('connection:status', (message) => {
      const { platformId } = message.data;
      return this.connectionManager.getStatus(platformId);
    });

    // æ¶ˆæ¯åˆ†å‘
    onMessage('message:send', async (message) => {
      const { content, platforms, mode, files } = message.data;
      const messageId = await this.dispatcher.broadcast({
        content,
        platforms,
        mode,
        files
      });
      return { messageId };
    });

    onMessage('message:cancel', async (message) => {
      const { messageId, platformId } = message.data;
      if (platformId) {
        await this.dispatcher.cancelPlatform(messageId, platformId);
      } else {
        await this.dispatcher.cancelAll(messageId);
      }
    });

    // å·¥ä½œå°åŒæ­¥
    onMessage('workspace:sync', () => {
      return this.getWorkspaceState();
    });
  }

  private getWorkspaceState(): WorkspaceState {
    return {
      connections: this.connectionManager.getAllConnections(),
      activeMessages: this.dispatcher.getActiveMessages(),
      config: this.getConfig()
    };
  }
}
```

### 3.3 Content Scripté€šä¿¡

```typescript
// entrypoints/content/index.ts
import { defineContentScript } from 'wxt/sandbox';
import { sendMessage } from '@/lib/messaging/protocol';
import { PlatformAdapter } from './adapters/base';
import { detectPlatform } from '@/utils/platform-detector';

export default defineContentScript({
  matches: [
    'https://chat.openai.com/*',
    'https://claude.ai/*',
    'https://gemini.google.com/*'
  ],

  async main(ctx) {
    console.log('OmniChat Content Script Loaded');

    // æ£€æµ‹å½“å‰å¹³å°
    const platform = detectPlatform(window.location.href);
    if (!platform) return;

    // åŠ¨æ€åŠ è½½é€‚é…å™¨
    const adapter = await loadAdapter(platform);

    // å»ºç«‹è¿æ¥
    const result = await sendMessage('connection:establish', {
      platformId: platform
    });

    if (result.success) {
      // åˆå§‹åŒ–é€‚é…å™¨
      await adapter.initialize();

      // è®¾ç½®æ¶ˆæ¯ç›‘å¬
      adapter.onResponse((chunk) => {
        sendMessage('response:chunk', {
          messageId: adapter.currentMessageId,
          platformId: platform,
          chunk: chunk.content,
          isComplete: chunk.isComplete
        });
      });

      // å¿ƒè·³ä¿æŒ
      ctx.setInterval(() => {
        sendMessage('connection:heartbeat', {
          platformId: platform,
          timestamp: Date.now()
        });
      }, 5000);
    }
  }
});

// åŠ¨æ€åŠ è½½å¹³å°é€‚é…å™¨
async function loadAdapter(platform: PlatformType): Promise<PlatformAdapter> {
  switch (platform) {
    case 'chatgpt':
      const { ChatGPTAdapter } = await import('./adapters/chatgpt');
      return new ChatGPTAdapter();
    case 'claude':
      const { ClaudeAdapter } = await import('./adapters/claude');
      return new ClaudeAdapter();
    case 'gemini':
      const { GeminiAdapter } = await import('./adapters/gemini');
      return new GeminiAdapter();
    default:
      throw new Error(`Unsupported platform: ${platform}`);
  }
}
```

## 4. Vueç»„ä»¶æ¶æ„

### 4.1 å·¥ä½œå°ä¸»ç•Œé¢

```vue
<!-- entrypoints/omnichat.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OmniChat å·¥ä½œå°</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="./omnichat/main.ts"></script>
</body>
</html>
```

```typescript
// entrypoints/omnichat/main.ts
import { createApp } from 'vue';
import { createPinia } from 'pinia';
import App from './App.vue';
import '@/assets/styles/global.css';

const app = createApp(App);
const pinia = createPinia();

app.use(pinia);
app.mount('#app');
```

```vue
<!-- entrypoints/omnichat/App.vue -->
<template>
  <div class="omnichat-workspace">
    <!-- ä¾§è¾¹æ ï¼šå¹³å°ç®¡ç† -->
    <PlatformSidebar
      v-model:collapsed="sidebarCollapsed"
      :platforms="platforms"
      @connect="handleConnect"
      @disconnect="handleDisconnect"
    />

    <!-- ä¸»å†…å®¹åŒº -->
    <main class="workspace-main">
      <!-- å·¥å…·æ  -->
      <WorkspaceToolbar
        :connected-count="connectedPlatforms.length"
        :view-mode="viewMode"
        @view-change="viewMode = $event"
        @cancel-all="handleCancelAll"
      />

      <!-- è¾“å…¥åŒºåŸŸ -->
      <MessageInput
        v-model="messageContent"
        :sending="isSending"
        :mode="broadcastMode"
        @send="handleSend"
        @mode-change="broadcastMode = $event"
        @attach-files="handleAttachFiles"
      />

      <!-- å“åº”å±•ç¤ºåŒº -->
      <ResponseGrid
        :responses="responses"
        :view-mode="viewMode"
        :loading-states="loadingStates"
        @cancel="handleCancelPlatform"
        @retry="handleRetryPlatform"
        @copy="handleCopyResponse"
      />
    </main>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { useWorkspaceStore } from '@/stores/workspace';
import { sendMessage } from '@/lib/messaging/protocol';
import PlatformSidebar from '@/components/workspace/PlatformSidebar.vue';
import WorkspaceToolbar from '@/components/workspace/WorkspaceToolbar.vue';
import MessageInput from '@/components/workspace/MessageInput.vue';
import ResponseGrid from '@/components/workspace/ResponseGrid.vue';

// çŠ¶æ€ç®¡ç†
const store = useWorkspaceStore();
const sidebarCollapsed = ref(false);
const messageContent = ref('');
const broadcastMode = ref<'new' | 'continue'>('new');
const viewMode = ref<ViewMode>('grid');
const isSending = ref(false);

// è®¡ç®—å±æ€§
const platforms = computed(() => store.platforms);
const connectedPlatforms = computed(() =>
  store.platforms.filter(p => p.connectionState === 'connected')
);
const responses = computed(() => store.currentResponses);
const loadingStates = computed(() => store.loadingStates);

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  // åŒæ­¥å·¥ä½œå°çŠ¶æ€
  const state = await sendMessage('workspace:sync');
  store.initializeState(state);
});

// æ–¹æ³•
async function handleConnect(platformId: PlatformType) {
  const result = await sendMessage('connection:establish', { platformId });
  if (result.success) {
    store.updatePlatformConnection(platformId, 'connected');
  }
}

async function handleDisconnect(platformId: PlatformType) {
  await sendMessage('connection:disconnect', { platformId });
  store.updatePlatformConnection(platformId, 'disconnected');
}

async function handleSend() {
  if (!messageContent.value.trim() || connectedPlatforms.value.length === 0) {
    return;
  }

  isSending.value = true;

  try {
    const { messageId } = await sendMessage('message:send', {
      content: messageContent.value,
      platforms: connectedPlatforms.value.map(p => p.id),
      mode: broadcastMode.value,
      files: store.attachedFiles
    });

    store.startNewMessage(messageId, messageContent.value);
    messageContent.value = '';
    store.clearAttachedFiles();
  } catch (error) {
    console.error('å‘é€å¤±è´¥:', error);
  } finally {
    isSending.value = false;
  }
}

async function handleCancelAll() {
  if (store.currentMessageId) {
    await sendMessage('message:cancel', {
      messageId: store.currentMessageId
    });
  }
}

async function handleCancelPlatform(platformId: PlatformType) {
  if (store.currentMessageId) {
    await sendMessage('message:cancel', {
      messageId: store.currentMessageId,
      platformId
    });
  }
}

async function handleRetryPlatform(platformId: PlatformType) {
  // é‡è¯•é€»è¾‘
  const lastMessage = store.getLastMessage();
  if (lastMessage) {
    const { messageId } = await sendMessage('message:send', {
      content: lastMessage.content,
      platforms: [platformId],
      mode: 'new'
    });
    store.retryPlatform(messageId, platformId);
  }
}

function handleCopyResponse(platformId: PlatformType) {
  const response = store.getResponse(platformId);
  if (response) {
    navigator.clipboard.writeText(response.content);
  }
}

function handleAttachFiles(files: File[]) {
  store.setAttachedFiles(files);
}
</script>

<style scoped>
.omnichat-workspace {
  display: flex;
  height: 100vh;
  background: var(--bg-primary);
}

.workspace-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
</style>
```

### 4.2 PiniaçŠ¶æ€ç®¡ç†

```typescript
// stores/workspace.ts
import { defineStore } from 'pinia';
import { onMessage } from '@/lib/messaging/protocol';

interface WorkspaceState {
  platforms: PlatformInfo[];
  currentMessageId: string | null;
  currentResponses: Map<PlatformType, ResponseData>;
  loadingStates: Map<PlatformType, MessageState>;
  messageHistory: Message[];
  attachedFiles: File[];
}

export const useWorkspaceStore = defineStore('workspace', {
  state: (): WorkspaceState => ({
    platforms: [],
    currentMessageId: null,
    currentResponses: new Map(),
    loadingStates: new Map(),
    messageHistory: [],
    attachedFiles: []
  }),

  getters: {
    connectedPlatforms: (state) => {
      return state.platforms.filter(p => p.connectionState === 'connected');
    },

    hasActiveRequests: (state) => {
      return Array.from(state.loadingStates.values()).some(
        state => state === 'sending' || state === 'receiving'
      );
    }
  },

  actions: {
    initializeState(state: WorkspaceState) {
      this.platforms = state.platforms;
      this.setupMessageListeners();
    },

    setupMessageListeners() {
      // ç›‘å¬å“åº”å—
      onMessage('response:chunk', (message) => {
        const { messageId, platformId, chunk, isComplete } = message.data;

        if (messageId === this.currentMessageId) {
          const current = this.currentResponses.get(platformId) || { content: '' };
          current.content += chunk;

          if (isComplete) {
            current.isComplete = true;
            this.loadingStates.set(platformId, 'completed');
          }

          this.currentResponses.set(platformId, current);
        }
      });

      // ç›‘å¬çŠ¶æ€æ›´æ–°
      onMessage('state:update', (message) => {
        const { messageId, platformId, state } = message.data;

        if (messageId === this.currentMessageId) {
          this.loadingStates.set(platformId, state);
        }
      });

      // ç›‘å¬é”™è¯¯
      onMessage('response:error', (message) => {
        const { messageId, platformId, error } = message.data;

        if (messageId === this.currentMessageId) {
          this.loadingStates.set(platformId, 'failed');
          this.currentResponses.set(platformId, {
            content: '',
            error: error.message,
            isComplete: true
          });
        }
      });
    },

    startNewMessage(messageId: string, content: string) {
      this.currentMessageId = messageId;
      this.currentResponses.clear();
      this.loadingStates.clear();

      // åˆå§‹åŒ–æ‰€æœ‰è¿æ¥å¹³å°çš„çŠ¶æ€
      this.connectedPlatforms.forEach(platform => {
        this.loadingStates.set(platform.id, 'sending');
      });

      // æ·»åŠ åˆ°å†å²
      this.messageHistory.push({
        id: messageId,
        content,
        timestamp: Date.now(),
        responses: new Map()
      });
    },

    updatePlatformConnection(platformId: PlatformType, state: ConnectionState) {
      const platform = this.platforms.find(p => p.id === platformId);
      if (platform) {
        platform.connectionState = state;
      }
    },

    getResponse(platformId: PlatformType): ResponseData | null {
      return this.currentResponses.get(platformId) || null;
    },

    getLastMessage(): Message | null {
      return this.messageHistory[this.messageHistory.length - 1] || null;
    },

    setAttachedFiles(files: File[]) {
      this.attachedFiles = files;
    },

    clearAttachedFiles() {
      this.attachedFiles = [];
    }
  }
});
```

## 5. å¹³å°é€‚é…å™¨å®ç°

### 5.1 åŸºç¡€é€‚é…å™¨ç±»

```typescript
// entrypoints/content/adapters/base.ts
export abstract class PlatformAdapter {
  protected platformId: PlatformType;
  protected selectors: PlatformSelectors;
  public currentMessageId: string | null = null;
  protected responseCallback: ((chunk: ResponseChunk) => void) | null = null;
  protected observer: MutationObserver | null = null;

  constructor(platformId: PlatformType, selectors: PlatformSelectors) {
    this.platformId = platformId;
    this.selectors = selectors;
  }

  abstract async initialize(): Promise<void>;
  abstract async sendMessage(content: string, mode: SendMode): Promise<void>;
  abstract async attachFiles(files: File[]): Promise<void>;
  abstract async cancelGeneration(): Promise<void>;
  abstract async detectResponseComplete(): Promise<boolean>;

  // é€šç”¨æ–¹æ³•
  onResponse(callback: (chunk: ResponseChunk) => void) {
    this.responseCallback = callback;
  }

  protected async waitForElement(
    selector: string,
    timeout = 5000
  ): Promise<Element> {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();

      const check = () => {
        const element = document.querySelector(selector);

        if (element) {
          resolve(element);
        } else if (Date.now() - startTime > timeout) {
          reject(new Error(`Element not found: ${selector}`));
        } else {
          requestAnimationFrame(check);
        }
      };

      check();
    });
  }

  protected watchForResponse() {
    if (this.observer) {
      this.observer.disconnect();
    }

    this.observer = new MutationObserver(async (mutations) => {
      const responseText = this.extractResponseText(mutations);

      if (responseText && this.responseCallback) {
        const isComplete = await this.detectResponseComplete();

        this.responseCallback({
          content: responseText,
          isComplete,
          timestamp: Date.now()
        });
      }
    });

    const container = document.querySelector(this.selectors.responseContainer);
    if (container) {
      this.observer.observe(container, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }
  }

  protected abstract extractResponseText(mutations: MutationRecord[]): string;

  protected async simulateTyping(
    element: HTMLElement,
    text: string
  ): Promise<void> {
    // æ¸…ç©ºç°æœ‰å†…å®¹
    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
      element.value = '';
    } else {
      element.textContent = '';
    }

    // èšç„¦å…ƒç´ 
    element.focus();

    // ä½¿ç”¨Inputäº‹ä»¶æ¨¡æ‹Ÿè¾“å…¥
    const inputEvent = new InputEvent('input', {
      data: text,
      inputType: 'insertText',
      bubbles: true,
      cancelable: true
    });

    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
      element.value = text;
    } else {
      element.textContent = text;
    }

    element.dispatchEvent(inputEvent);

    // è§¦å‘changeäº‹ä»¶
    element.dispatchEvent(new Event('change', { bubbles: true }));
  }

  protected async clickElement(element: HTMLElement): Promise<void> {
    // æ»šåŠ¨åˆ°å…ƒç´ 
    element.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // ç­‰å¾…æ»šåŠ¨å®Œæˆ
    await new Promise(resolve => setTimeout(resolve, 300));

    // æ¨¡æ‹Ÿç‚¹å‡»
    element.click();

    // å¤‡ç”¨æ–¹æ¡ˆï¼šå¦‚æœclickä¸ç”Ÿæ•ˆï¼Œä½¿ç”¨äº‹ä»¶
    const clickEvent = new MouseEvent('click', {
      view: window,
      bubbles: true,
      cancelable: true
    });
    element.dispatchEvent(clickEvent);
  }

  cleanup() {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }
    this.responseCallback = null;
    this.currentMessageId = null;
  }
}
```

### 5.2 ChatGPTé€‚é…å™¨å®ç°

```typescript
// entrypoints/content/adapters/chatgpt.ts
import { PlatformAdapter } from './base';

export class ChatGPTAdapter extends PlatformAdapter {
  constructor() {
    super('chatgpt', {
      inputBox: '#prompt-textarea',
      sendButton: '[data-testid="send-button"]',
      newChatButton: 'nav a[href="/"]',
      responseContainer: '[data-message-author-role="assistant"]',
      responseContent: '.markdown',
      stopButton: 'button[aria-label="Stop generating"]',
      regenerateButton: 'button:contains("Regenerate")',
      fileInput: 'input[type="file"]',
      loadingIndicator: '.result-streaming'
    });
  }

  async initialize(): Promise<void> {
    console.log('Initializing ChatGPT Adapter');

    // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
    await this.waitForElement(this.selectors.inputBox);

    // å¼€å§‹ç›‘å¬å“åº”
    this.watchForResponse();
  }

  async sendMessage(content: string, mode: SendMode): Promise<void> {
    // å¦‚æœæ˜¯æ–°å¯¹è¯æ¨¡å¼ï¼Œå…ˆåˆ›å»ºæ–°å¯¹è¯
    if (mode === 'new') {
      await this.startNewChat();
    }

    // è·å–è¾“å…¥æ¡†
    const inputBox = await this.waitForElement(this.selectors.inputBox) as HTMLTextAreaElement;

    // è¾“å…¥æ¶ˆæ¯
    await this.simulateTyping(inputBox, content);

    // ç­‰å¾…å‘é€æŒ‰é’®å¯ç”¨
    await this.waitForElement(this.selectors.sendButton);

    // ç‚¹å‡»å‘é€
    const sendButton = document.querySelector(this.selectors.sendButton) as HTMLButtonElement;
    await this.clickElement(sendButton);
  }

  private async startNewChat(): Promise<void> {
    const newChatButton = document.querySelector(this.selectors.newChatButton) as HTMLElement;

    if (newChatButton) {
      await this.clickElement(newChatButton);
      // ç­‰å¾…æ–°å¯¹è¯åˆ›å»º
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  async attachFiles(files: File[]): Promise<void> {
    const fileInput = document.querySelector(this.selectors.fileInput) as HTMLInputElement;

    if (!fileInput) {
      throw new Error('File input not found');
    }

    // åˆ›å»ºDataTransferå¯¹è±¡æ¥è®¾ç½®æ–‡ä»¶
    const dataTransfer = new DataTransfer();
    files.forEach(file => dataTransfer.items.add(file));

    fileInput.files = dataTransfer.files;

    // è§¦å‘changeäº‹ä»¶
    fileInput.dispatchEvent(new Event('change', { bubbles: true }));
  }

  async cancelGeneration(): Promise<void> {
    const stopButton = document.querySelector(this.selectors.stopButton) as HTMLButtonElement;

    if (stopButton && !stopButton.disabled) {
      await this.clickElement(stopButton);
    }
  }

  async detectResponseComplete(): Promise<boolean> {
    // æ£€æŸ¥æ˜¯å¦è¿˜åœ¨æµå¼è¾“å‡ºä¸­
    const loadingIndicator = document.querySelector(this.selectors.loadingIndicator);
    const stopButton = document.querySelector(this.selectors.stopButton);

    return !loadingIndicator && !stopButton;
  }

  protected extractResponseText(mutations: MutationRecord[]): string {
    // è·å–æœ€æ–°çš„åŠ©æ‰‹å“åº”
    const responseElements = document.querySelectorAll(this.selectors.responseContainer);

    if (responseElements.length === 0) return '';

    const latestResponse = responseElements[responseElements.length - 1];
    const contentElement = latestResponse.querySelector(this.selectors.responseContent);

    return contentElement?.textContent || '';
  }
}

### 5.3 Claudeé€‚é…å™¨å®ç°

```typescript
// entrypoints/content/adapters/claude.ts
import { PlatformAdapter } from './base';

export class ClaudeAdapter extends PlatformAdapter {
  constructor() {
    super('claude', {
      inputBox: 'div[contenteditable="true"]',
      sendButton: 'button[aria-label*="Send"]',
      newChatButton: 'button[aria-label*="New chat"]',
      responseContainer: 'div[data-test-id="message-assistant"]',
      responseContent: '.prose',
      stopButton: 'button[aria-label*="Stop"]',
      regenerateButton: 'button[aria-label*="Retry"]',
      fileInput: 'input[type="file"]',
      loadingIndicator: '[data-test-id="loading-indicator"]'
    });
  }

  async initialize(): Promise<void> {
    console.log('Initializing Claude Adapter');
    await this.waitForElement(this.selectors.inputBox);
    this.watchForResponse();
  }

  async sendMessage(content: string, mode: SendMode): Promise<void> {
    if (mode === 'new') {
      await this.startNewChat();
    }

    const inputBox = await this.waitForElement(this.selectors.inputBox) as HTMLElement;

    // Claudeä½¿ç”¨contenteditableï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
    inputBox.focus();
    inputBox.textContent = content;

    // è§¦å‘è¾“å…¥äº‹ä»¶
    inputBox.dispatchEvent(new InputEvent('input', {
      data: content,
      inputType: 'insertText',
      bubbles: true
    }));

    // å‘é€æ¶ˆæ¯
    const sendButton = await this.waitForElement(this.selectors.sendButton) as HTMLButtonElement;
    await this.clickElement(sendButton);
  }

  private async startNewChat(): Promise<void> {
    const newChatButton = document.querySelector(this.selectors.newChatButton) as HTMLElement;
    if (newChatButton) {
      await this.clickElement(newChatButton);
      await new Promise(resolve => setTimeout(resolve, 800));
    }
  }

  async attachFiles(files: File[]): Promise<void> {
    // Claudeçš„æ–‡ä»¶ä¸Šä¼ é€»è¾‘
    const fileInput = document.querySelector(this.selectors.fileInput) as HTMLInputElement;
    if (!fileInput) throw new Error('File input not found');

    const dataTransfer = new DataTransfer();
    files.forEach(file => dataTransfer.items.add(file));
    fileInput.files = dataTransfer.files;
    fileInput.dispatchEvent(new Event('change', { bubbles: true }));
  }

  async cancelGeneration(): Promise<void> {
    const stopButton = document.querySelector(this.selectors.stopButton) as HTMLButtonElement;
    if (stopButton) {
      await this.clickElement(stopButton);
    }
  }

  async detectResponseComplete(): Promise<boolean> {
    const loadingIndicator = document.querySelector(this.selectors.loadingIndicator);
    return !loadingIndicator;
  }

  protected extractResponseText(mutations: MutationRecord[]): string {
    const responseElements = document.querySelectorAll(this.selectors.responseContainer);
    if (responseElements.length === 0) return '';

    const latestResponse = responseElements[responseElements.length - 1];
    const contentElement = latestResponse.querySelector(this.selectors.responseContent);

    return contentElement?.textContent || '';
  }
}
```

## 6. å­˜å‚¨ç®¡ç†ï¼ˆä½¿ç”¨@webext-core/storageï¼‰

### 6.1 å­˜å‚¨é…ç½®

```typescript
// lib/storage/index.ts
import { defineExtensionStorage } from '@webext-core/storage';

// å®šä¹‰å­˜å‚¨æ•°æ®ç»“æ„
interface StorageData {
  // ç”¨æˆ·é…ç½®
  userConfig: {
    enabledPlatforms: PlatformType[];
    defaultMode: 'new' | 'continue';
    theme: 'light' | 'dark' | 'auto';
    viewMode: ViewMode;
    autoSave: boolean;
  };

  // ä¼šè¯å†å²
  sessions: SessionData[];

  // å¹³å°é…ç½®
  platformSettings: Record<PlatformType, PlatformSettings>;

  // ç»Ÿè®¡æ•°æ®
  statistics: {
    totalMessages: number;
    platformUsage: Record<PlatformType, number>;
    lastUsed: number;
  };
}

// åˆ›å»ºå­˜å‚¨å®ä¾‹
export const storage = defineExtensionStorage<StorageData>({
  // é»˜è®¤å€¼
  userConfig: {
    enabledPlatforms: ['chatgpt', 'claude', 'gemini'],
    defaultMode: 'new',
    theme: 'auto',
    viewMode: 'grid',
    autoSave: true
  },

  sessions: [],

  platformSettings: {},

  statistics: {
    totalMessages: 0,
    platformUsage: {},
    lastUsed: Date.now()
  }
});

// ä¼šè¯ç®¡ç†
export class SessionManager {
  private readonly MAX_SESSIONS = 100;
  private readonly SESSION_RETENTION_DAYS = 30;

  async saveSession(session: SessionData): Promise<void> {
    const sessions = await storage.sessions.getValue();

    // æ·»åŠ æ–°ä¼šè¯
    sessions.unshift(session);

    // é™åˆ¶æ•°é‡
    if (sessions.length > this.MAX_SESSIONS) {
      sessions.length = this.MAX_SESSIONS;
    }

    // æ¸…ç†è¿‡æœŸä¼šè¯
    const cutoffTime = Date.now() - (this.SESSION_RETENTION_DAYS * 24 * 60 * 60 * 1000);
    const validSessions = sessions.filter(s => s.timestamp > cutoffTime);

    await storage.sessions.setValue(validSessions);
  }

  async getRecentSessions(limit = 10): Promise<SessionData[]> {
    const sessions = await storage.sessions.getValue();
    return sessions.slice(0, limit);
  }

  async searchSessions(query: string): Promise<SessionData[]> {
    const sessions = await storage.sessions.getValue();
    const lowerQuery = query.toLowerCase();

    return sessions.filter(session =>
      session.content.toLowerCase().includes(lowerQuery) ||
      session.responses.some(r => r.content.toLowerCase().includes(lowerQuery))
    );
  }

  async deleteSession(sessionId: string): Promise<void> {
    const sessions = await storage.sessions.getValue();
    const filtered = sessions.filter(s => s.id !== sessionId);
    await storage.sessions.setValue(filtered);
  }

  async exportSessions(): Promise<string> {
    const sessions = await storage.sessions.getValue();
    return JSON.stringify(sessions, null, 2);
  }

  async importSessions(json: string): Promise<void> {
    try {
      const imported = JSON.parse(json) as SessionData[];
      const current = await storage.sessions.getValue();

      // åˆå¹¶å¯¼å…¥çš„ä¼šè¯
      const merged = [...imported, ...current];

      // å»é‡
      const unique = Array.from(
        new Map(merged.map(s => [s.id, s])).values()
      );

      await storage.sessions.setValue(unique);
    } catch (error) {
      throw new Error('Invalid session data format');
    }
  }
}
```

### 6.2 é…ç½®ç®¡ç†

```typescript
// lib/storage/config-manager.ts
import { storage } from './index';

export class ConfigManager {
  // è·å–ç”¨æˆ·é…ç½®
  async getUserConfig() {
    return await storage.userConfig.getValue();
  }

  // æ›´æ–°é…ç½®é¡¹
  async updateConfig(key: keyof UserConfig, value: any) {
    const config = await storage.userConfig.getValue();
    config[key] = value;
    await storage.userConfig.setValue(config);
  }

  // è·å–å¯ç”¨çš„å¹³å°
  async getEnabledPlatforms(): Promise<PlatformType[]> {
    const config = await storage.userConfig.getValue();
    return config.enabledPlatforms;
  }

  // åˆ‡æ¢å¹³å°å¯ç”¨çŠ¶æ€
  async togglePlatform(platformId: PlatformType, enabled: boolean) {
    const config = await storage.userConfig.getValue();

    if (enabled && !config.enabledPlatforms.includes(platformId)) {
      config.enabledPlatforms.push(platformId);
    } else if (!enabled) {
      config.enabledPlatforms = config.enabledPlatforms.filter(p => p !== platformId);
    }

    await storage.userConfig.setValue(config);
  }

  // è·å–å¹³å°è®¾ç½®
  async getPlatformSettings(platformId: PlatformType): Promise<PlatformSettings> {
    const settings = await storage.platformSettings.getValue();
    return settings[platformId] || this.getDefaultSettings(platformId);
  }

  // æ›´æ–°å¹³å°è®¾ç½®
  async updatePlatformSettings(
    platformId: PlatformType,
    settings: Partial<PlatformSettings>
  ) {
    const allSettings = await storage.platformSettings.getValue();
    allSettings[platformId] = {
      ...allSettings[platformId],
      ...settings
    };
    await storage.platformSettings.setValue(allSettings);
  }

  private getDefaultSettings(platformId: PlatformType): PlatformSettings {
    return {
      autoReconnect: true,
      timeout: 30000,
      retryAttempts: 3,
      customPromptPrefix: '',
      customPromptSuffix: ''
    };
  }
}
```

## 7. å¼€å‘ä¸è°ƒè¯•

### 7.1 å¼€å‘å‘½ä»¤

```json
// package.json
{
  "name": "omnichat",
  "version": "1.0.0",
  "scripts": {
    "dev": "wxt",
    "dev:firefox": "wxt --browser firefox",
    "build": "wxt build",
    "build:firefox": "wxt build --browser firefox",
    "zip": "wxt zip",
    "postinstall": "wxt prepare",
    "type-check": "vue-tsc --noEmit",
    "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts",
    "test": "vitest",
    "test:ui": "vitest --ui"
  },
  "dependencies": {
    "@webext-core/messaging": "^1.4.0",
    "@webext-core/storage": "^1.3.1",
    "pinia": "^2.1.7",
    "vue": "^3.4.21"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.4",
    "@vue/test-utils": "^2.4.5",
    "@wxt-dev/module-vue": "^1.0.0",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.57.0",
    "eslint-plugin-vue": "^9.23.0",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.3",
    "typescript": "^5.4.3",
    "vite": "^5.2.8",
    "vitest": "^1.4.0",
    "vue-tsc": "^2.0.7",
    "wxt": "^0.17.0"
  }
}
```

### 7.2 å¼€å‘å·¥å…·é›†æˆ

```typescript
// utils/dev-tools.ts
export class DevTools {
  private static isDev = import.meta.env.DEV;

  // æ¶ˆæ¯è°ƒè¯•
  static logMessage(type: string, data: any) {
    if (!this.isDev) return;

    console.group(`ğŸ” OmniChat Message: ${type}`);
    console.log('Timestamp:', new Date().toISOString());
    console.log('Data:', data);
    console.trace('Stack Trace');
    console.groupEnd();
  }

  // æ€§èƒ½ç›‘æ§
  static measurePerformance(name: string, fn: () => any) {
    if (!this.isDev) return fn();

    const start = performance.now();
    const result = fn();
    const end = performance.now();

    console.log(`âš¡ Performance: ${name} took ${(end - start).toFixed(2)}ms`);

    return result;
  }

  // æ¨¡æ‹Ÿå»¶è¿Ÿ
  static async simulateDelay(ms: number) {
    if (this.isDev) {
      await new Promise(resolve => setTimeout(resolve, ms));
    }
  }

  // çŠ¶æ€æ£€æŸ¥å™¨
  static checkState() {
    if (!this.isDev) return;

    // æ£€æŸ¥æ‰€æœ‰æ ‡ç­¾é¡µçš„Content ScriptçŠ¶æ€
    browser.tabs.query({}).then(tabs => {
      tabs.forEach(tab => {
        if (tab.id) {
          browser.tabs.sendMessage(tab.id, { type: 'PING' })
            .then(() => console.log(`âœ… Tab ${tab.id} responsive`))
            .catch(() => console.log(`âŒ Tab ${tab.id} not responsive`));
        }
      });
    });
  }

  // é”™è¯¯æŠ¥å‘Š
  static reportError(error: Error, context?: any) {
    console.error('âŒ OmniChat Error:', error);

    if (context) {
      console.error('Context:', context);
    }

    if (this.isDev) {
      // å¼€å‘æ¨¡å¼ä¸‹æ˜¾ç¤ºé€šçŸ¥
      browser.notifications.create({
        type: 'basic',
        iconUrl: '/icons/icon-48.png',
        title: 'OmniChat Error',
        message: error.message
      });
    }
  }
}
```

## 8. æµ‹è¯•ç­–ç•¥

### 8.1 å•å…ƒæµ‹è¯•ç¤ºä¾‹

```typescript
// tests/unit/message-dispatcher.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { MessageDispatcher } from '@/lib/messaging/dispatcher';
import { ConnectionManager } from '@/lib/platforms/connection-manager';

describe('MessageDispatcher', () => {
  let dispatcher: MessageDispatcher;
  let connectionManager: ConnectionManager;

  beforeEach(() => {
    connectionManager = new ConnectionManager();
    dispatcher = new MessageDispatcher(connectionManager);
  });

  it('should broadcast message to all connected platforms', async () => {
    // Mockè¿æ¥
    vi.spyOn(connectionManager, 'getConnectedPlatforms').mockReturnValue([
      { id: 'chatgpt', state: 'connected' },
      { id: 'claude', state: 'connected' }
    ]);

    const messageId = await dispatcher.broadcast({
      content: 'Test message',
      platforms: ['chatgpt', 'claude'],
      mode: 'new'
    });

    expect(messageId).toBeDefined();
    expect(dispatcher.getActiveMessages()).toContain(messageId);
  });

  it('should handle platform-specific cancellation', async () => {
    const messageId = 'test-message-id';

    await dispatcher.cancelPlatform(messageId, 'chatgpt');

    // éªŒè¯åªæœ‰ChatGPTè¢«å–æ¶ˆ
    const state = dispatcher.getPlatformState(messageId, 'chatgpt');
    expect(state).toBe('cancelled');
  });

  it('should retry failed messages', async () => {
    const messageId = 'test-message-id';

    // æ¨¡æ‹Ÿå¤±è´¥
    dispatcher.updateState(messageId, 'chatgpt', 'failed');

    // é‡è¯•
    await dispatcher.retryPlatform(messageId, 'chatgpt');

    // éªŒè¯çŠ¶æ€æ›´æ–°
    const state = dispatcher.getPlatformState(messageId, 'chatgpt');
    expect(state).toBe('sending');
  });
});
```

### 8.2 ç»„ä»¶æµ‹è¯•

```typescript
// tests/components/MessageInput.test.ts
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import MessageInput from '@/components/workspace/MessageInput.vue';

describe('MessageInput Component', () => {
  it('should emit send event with message content', async () => {
    const wrapper = mount(MessageInput, {
      props: {
        modelValue: '',
        sending: false,
        mode: 'new'
      }
    });

    // è¾“å…¥æ¶ˆæ¯
    const textarea = wrapper.find('textarea');
    await textarea.setValue('Test message');

    // ç‚¹å‡»å‘é€æŒ‰é’®
    const sendButton = wrapper.find('[data-test="send-button"]');
    await sendButton.trigger('click');

    // éªŒè¯äº‹ä»¶
    expect(wrapper.emitted('send')).toBeTruthy();
    expect(wrapper.emitted('update:modelValue')?.[0]).toEqual(['Test message']);
  });

  it('should disable send button when sending', () => {
    const wrapper = mount(MessageInput, {
      props: {
        modelValue: 'Test',
        sending: true,
        mode: 'new'
      }
    });

    const sendButton = wrapper.find('[data-test="send-button"]');
    expect(sendButton.attributes('disabled')).toBeDefined();
  });

  it('should handle file attachments', async () => {
    const wrapper = mount(MessageInput);

    const file = new File(['test'], 'test.txt', { type: 'text/plain' });
    const fileInput = wrapper.find('input[type="file"]');

    // æ¨¡æ‹Ÿæ–‡ä»¶é€‰æ‹©
    Object.defineProperty(fileInput.element, 'files', {
      value: [file],
      writable: false
    });

    await fileInput.trigger('change');

    // éªŒè¯æ–‡ä»¶é™„ä»¶äº‹ä»¶
    expect(wrapper.emitted('attach-files')).toBeTruthy();
    expect(wrapper.emitted('attach-files')?.[0]?.[0]).toContainEqual(file);
  });
});
```

## 9. éƒ¨ç½²ä¸å‘å¸ƒ

### 9.1 æ„å»ºé…ç½®

```typescript
// wxt.config.ts (ç”Ÿäº§æ„å»ºé…ç½®)
import { defineConfig } from 'wxt';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  vite: () => ({
    plugins: [vue()],
    build: {
      // ç”Ÿäº§ä¼˜åŒ–
      minify: 'terser',
      terserOptions: {
        compress: {
          drop_console: true,
          drop_debugger: true
        }
      },
      rollupOptions: {
        output: {
          manualChunks: {
            'vendor-vue': ['vue', 'pinia'],
            'vendor-messaging': ['@webext-core/messaging', '@webext-core/storage'],
            'vendor-ui': ['@headlessui/vue', '@heroicons/vue']
          }
        }
      }
    }
  }),

  // ç”Ÿäº§ç¯å¢ƒmanifest
  manifest: (env) => ({
    ...baseManifest,
    version: process.env.npm_package_version,
    version_name: env.mode === 'production' ? undefined : 'Dev Build',

    // ç”Ÿäº§ç¯å¢ƒCSP
    content_security_policy: {
      extension_pages: env.mode === 'production'
        ? "script-src 'self'; object-src 'self'"
        : "script-src 'self' 'unsafe-eval'; object-src 'self'"
    }
  }),

  // è‡ªåŠ¨å‘å¸ƒé…ç½®
  publishConfig: {
    chrome: {
      clientId: process.env.CHROME_CLIENT_ID,
      clientSecret: process.env.CHROME_CLIENT_SECRET,
      refreshToken: process.env.CHROME_REFRESH_TOKEN,
      extensionId: process.env.CHROME_EXTENSION_ID
    },
    firefox: {
      jwtIssuer: process.env.FIREFOX_JWT_ISSUER,
      jwtSecret: process.env.FIREFOX_JWT_SECRET,
      extensionId: process.env.FIREFOX_EXTENSION_ID
    }
  }
});
```

### 9.2 å‘å¸ƒæµç¨‹

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build extension
        run: |
          npm run build
          npm run build:firefox

      - name: Package extensions
        run: npm run zip

      - name: Upload to Chrome Web Store
        if: success()
        run: npx wxt publish:chrome
        env:
          CHROME_CLIENT_ID: ${{ secrets.CHROME_CLIENT_ID }}
          CHROME_CLIENT_SECRET: ${{ secrets.CHROME_CLIENT_SECRET }}
          CHROME_REFRESH_TOKEN: ${{ secrets.CHROME_REFRESH_TOKEN }}

      - name: Upload to Firefox Add-ons
        if: success()
        run: npx wxt publish:firefox
        env:
          FIREFOX_JWT_ISSUER: ${{ secrets.FIREFOX_JWT_ISSUER }}
          FIREFOX_JWT_SECRET: ${{ secrets.FIREFOX_JWT_SECRET }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            .output/*.zip
          draft: false
          prerelease: false
```

## 10. æ€»ç»“

### 10.1 WXTæ¡†æ¶ä¼˜åŠ¿

1. **å¼€å‘ä½“éªŒä¼˜ç§€**
   - HMRæ”¯æŒï¼Œå®æ—¶æ›´æ–°
   - è‡ªåŠ¨ç”Ÿæˆmanifest
   - TypeScriptåŸç”Ÿæ”¯æŒ
   - æ–‡ä»¶è·¯ç”±ç³»ç»Ÿ

2. **è·¨æµè§ˆå™¨å…¼å®¹**
   - åŒä¸€ä»£ç åº“æ”¯æŒChrome/Firefox/Safari
   - è‡ªåŠ¨å¤„ç†Manifest V2/V3å·®å¼‚
   - æµè§ˆå™¨ç‰¹å®šé…ç½®æ”¯æŒ

3. **å·¥å…·é“¾å®Œå–„**
   - å†…ç½®Viteæ„å»º
   - è‡ªåŠ¨æ‰“åŒ…å‘å¸ƒ
   - æµ‹è¯•æ¡†æ¶é›†æˆ
   - å¼€å‘è€…å·¥å…·æ”¯æŒ

### 10.2 @webext-coreä¼˜åŠ¿

1. **ç±»å‹å®‰å…¨**
   - å®Œæ•´çš„TypeScriptç±»å‹å®šä¹‰
   - ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
   - IDEæ™ºèƒ½æç¤º

2. **ç®€åŒ–API**
   - ç»Ÿä¸€çš„æ¶ˆæ¯ä¼ é€’æ¥å£
   - ç®€åŒ–çš„å­˜å‚¨ç®¡ç†
   - æ›´å¥½çš„é”™è¯¯å¤„ç†

3. **è·¨æµè§ˆå™¨æ”¯æŒ**
   - åŸºäºwebextension-polyfill
   - è‡ªåŠ¨å¤„ç†æµè§ˆå™¨å·®å¼‚
   - PromiseåŒ–çš„API

### 10.3 æ¶æ„ç‰¹ç‚¹

1. **æ¨¡å—åŒ–è®¾è®¡**
   - æ¸…æ™°çš„æ¨¡å—è¾¹ç•Œ
   - å¯ç‹¬ç«‹æµ‹è¯•å’Œç»´æŠ¤
   - æ˜“äºæ‰©å±•æ–°å¹³å°

2. **æ€§èƒ½ä¼˜åŒ–**
   - ä»£ç åˆ†å‰²
   - æ‡’åŠ è½½
   - è™šæ‹Ÿæ»šåŠ¨

3. **å¼€å‘å‹å¥½**
   - çƒ­é‡è½½æ”¯æŒ
   - å®Œå–„çš„è°ƒè¯•å·¥å…·
   - è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯

é€šè¿‡ä½¿ç”¨WXTæ¡†æ¶å’Œ@webext-core/messagingï¼ŒOmniChaté¡¹ç›®èƒ½å¤Ÿè·å¾—æ›´å¥½çš„å¼€å‘ä½“éªŒã€æ›´å¼ºçš„ç±»å‹å®‰å…¨æ€§ï¼Œä»¥åŠæ›´ç®€æ´çš„ä»£ç ç»“æ„ã€‚è¿™ä¸ªæ¶æ„è®¾è®¡å……åˆ†åˆ©ç”¨äº†ç°ä»£Webæ‰©å±•å¼€å‘çš„æœ€ä½³å®è·µï¼Œä¸ºé¡¹ç›®çš„é•¿æœŸç»´æŠ¤å’Œæ‰©å±•å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚
